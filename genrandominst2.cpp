/*
 * GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem from a graph
 * Made in 2018 by Daniel Severin and Mauro Lucci
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <cstring>
#include <set>

using namespace std;


/* FUNCTIONS */

/*
 * bye - finish executing and show a message
 */
void bye(char *string)
{
	cout << string << endl;
	exit(1);
}

/*
* urnd - generate numbers with uniform random distribution
*  if flag=false, the interval is [a, b]
*  if flag=true, the interval is [a, b)
*/
float urnd(float a, float b, bool flag)
{
    if (!flag)
        return a + rand() * (b - a) / (float) RAND_MAX;
	else
        return a + (rand() % RAND_MAX) * (b - a) / (float) RAND_MAX;
}

/*
 * main - Main program
 */
int main(int argc, char **argv)
{
	cout << "GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem." << endl;

	char *filename = argv[1];
	bool transport = true;
	int colors, size;
	float lb_cost, ub_cost;

	if (argc < 6) {
		cout << "Usage: genrandominst file [colors lb_cost ub_cost size] " << endl;
		cout << "It takes file.graph and generates file.cost and file.list." << endl;
		cout << "Parameters:" << endl;
		cout << "  colors = number of colors" << endl;
		cout << "  lb_cost, ub_cost = bounds on the cost of each color (generated by a uniform distribution)" << endl;
		cout << "  size = size of the lists of colors" << endl;
		bye("Bye!");
	}
	else {
		colors = atoi(argv[2]);
		if (colors < 2 || colors > 50000) bye("Number of colors out range!");
		lb_cost = atof(argv[3]);
		ub_cost = atof(argv[4]);
		if (lb_cost < 1.0 || lb_cost > ub_cost || ub_cost > 1000.0) bye("Bounds should satisfy 1 <= lb_cost <= ub_cost <= 1000!");
		size = atoi(argv[5]);
		if (size < 2 || size > colors) bye("List size out of range");
		transport = false;
    }

	/* open graph file */
	char filename_extension[210];
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".graph");
	FILE *stream = fopen(filename_extension, "rt");
	if (!stream) bye("Graph file cannot be opened");
	int vertices, edges;
	fscanf(stream, "%d:%d\n", &vertices, &edges);

	/* do not accept graph of less than 4 vertices or stable sets */
	if (vertices < 4) bye("Number of vertices out range!");
	if (edges < 1 || edges > vertices*(vertices - 1) / 2) bye("Number of edges out of range!");

	cout << "Statistics:" << endl;
	int clique_size = vertices * (vertices - 1) / 2;
	float density = 100.0 * (float)edges / (float)clique_size;
	cout << "  |V| = " << vertices << ", |E| = " << edges << " (density = " << density << "%), |C| = " << colors << "." << endl;

	/* generate costs and write them to file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".cost");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("Cost file cannot be created");
	fprintf(stream, "%d\n", colors);
	for (int k = 0; k < colors; k++) {
		int cost = (int)urnd(lb_cost, ub_cost, false);
		fprintf(stream, "%d ", cost);
	}
	fprintf(stream, "\n");
	fclose(stream);

	/* generate lists of colors */
	cout << "Using size of L(v) = " << size << "." << endl;
	int *L_size = new int[vertices];
	int **L_set = new int*[vertices];
	for (int v = 0; v < vertices; v++) {
		L_size[v] = size;
		L_set[v] = new int[size];
        set<int> s;
        while (s.size() < size) {
		    int k = (int)urnd(0, colors, true);
		    s.insert(k);
        }
        auto it = s.begin();
        for (int i = 0; i < size; i++) {
		    L_set[v][i] = *it;
            ++it;
        }
	}

	/* write them to list file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".list");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("List file cannot be created");
	fprintf(stream, "%d:%d\n", vertices, colors);
	for (int v = 0; v < vertices; v++) {
		int lv = L_size[v];
		fprintf(stream, "%d ", lv);
		for (int s = 0; s < lv; s++) fprintf(stream, "%d ", L_set[v][s]);
		fprintf(stream, "\n");
	}
	fclose(stream);

	/* free memory */
	for (int v = 0; v < vertices; v++) delete[] L_set[v];
	delete[] L_set;
	delete[] L_size;
	//delete[] edge_v;
	//delete[] edge_u;
	//for (int v = 0; v < vertices; v++) delete[] adjacency[v];
	//delete[] adjacency;
	//delete[] degrees;
	return 0;
}
