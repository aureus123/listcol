/*
 * GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem from a graph
 * Made in 2018 by Daniel Severin and Mauro Lucci
 *
 */

#include "io.h"
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <cstring>
#include <set>
#include <unistd.h>
#include <vector>
#include <list>

using namespace std;


/* FUNCTIONS */

/*
 * bye - finish executing and show a message
 */
void bye(char *string)
{
	cout << string << endl;
	exit(1);
}

/*
* urnd - generate numbers with uniform random distribution
*  if flag=false, the interval is [a, b]
*  if flag=true, the interval is [a, b)
*/
float urnd(float a, float b, bool flag)
{
    if (!flag)
        return a + rand() * (b - a) / (float) RAND_MAX;
	else
        return a + (rand() % RAND_MAX) * (b - a) / (float) RAND_MAX;
}

/*
 * main - Main program
 */
int main(int argc, char **argv)
{
	cout << "GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem." << endl;

    sleep (1);
    srand (time(NULL)); // seed

	char *filename = argv[1];
	int colors;
	float c, p, lb_cost, ub_cost;

	if (argc < 6) {
		cout << "Usage: genrandominst file c p lb_cost ub_cost " << endl;
		cout << "It takes file.graph and generates file.cost and file.list." << endl;
		cout << "Parameters:" << endl;
		cout << "  c: |C| = c*|V|" << endl; 
		cout << "  p: probability of a color to belong to a list" << endl;        
		cout << "  lb_cost, ub_cost = bounds on the cost of each color (generated by a uniform distribution)" << endl;
		bye("Bye!");
	}
	else {
        c = (float) atoi(argv[2]) / 100;
        if (c <= 0) bye("c should satisfy 0 < c"); 
        p = (float) atoi(argv[3]) / 100;
		if (p <= 0 || p > 1) bye("p should satisfy 0 < p <= 1");
		lb_cost = atof(argv[4]);
		ub_cost = atof(argv[5]);
		if (lb_cost < 1.0 || lb_cost > ub_cost || ub_cost > 1000.0) bye("Bounds should satisfy 1 <= lb_cost <= ub_cost <= 1000!");
    }

	/* open graph file */
	char filename_extension[210];
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".graph");
	FILE *stream = fopen(filename_extension, "rt");
	if (!stream) bye("Graph file cannot be opened");
	int vertices, edges;
	fscanf(stream, "%d:%d\n", &vertices, &edges);
	fclose(stream);

	/* do not accept graph of less than 4 vertices or stable sets */
	if (vertices < 4) bye("Number of vertices out range!");
	if (edges < 1 || edges > vertices*(vertices - 1) / 2) bye("Number of edges out of range!");
    colors = round(vertices * c);
    if (colors < 2 || colors > 50000) bye("Number of colors out range!");

	cout << "Statistics:" << endl;
	int clique_size = vertices * (vertices - 1) / 2;
	float density = 100.0 * (float)edges / (float)clique_size;
	cout << "  |V| = " << vertices << ", |E| = " << edges << " (density = " << density << "%), |C| = " << colors << ", |Lv| = " << (int) (p*colors) << "(aprox)." << endl;

	/* generate costs and write them to file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".cost");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("Cost file cannot be created");
	fprintf(stream, "%d\n", colors);
	for (int k = 0; k < colors; k++) {
		int cost = (int)urnd(lb_cost, ub_cost, false);
		fprintf(stream, "%d ", cost);
	}
	fprintf(stream, "\n");
	fclose(stream);

	/* generate lists of colors */
	vector<list<int>> L (vertices);
	for (int v = 0; v < vertices; v++) {
		
		for(int k = 0; k < colors; k++)
		{
			if (rand() / (float) RAND_MAX <= p) {
				L[v].push_back(k);
			}
		}
		
	}

	/* write them to list file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".list");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("List file cannot be created");
	fprintf(stream, "%d:%d\n", vertices, colors);
	for (int v = 0; v < vertices; v++) {
		fprintf(stream, "%d ", L[v].size());
		for (int k : L[v]) fprintf(stream, "%d ", k);
		fprintf(stream, "\n");
	}
	fclose(stream);

	/* free memory */
	//delete[] edge_v;
	//delete[] edge_u;
	//for (int v = 0; v < vertices; v++) delete[] adjacency[v];
	//delete[] adjacency;
	//delete[] degrees;
	return 0;
}
