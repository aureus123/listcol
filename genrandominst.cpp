/*
 * GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem from a graph
 * Made in 2018-2019 by Daniel Severin
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <iostream>

#ifdef VISUALC
#include <ctime>
#endif

using namespace std;

/* PI + CONSTANTS FOR A TRANSPORT INSTANCE */

#define PI 3.14159265358979323846
#define INFDIST 9999999

#define EDGES_PER_COLOR 3.14
#define LOG_COLORS_PER_AVERAGE 0.785
#define AVERAGES_PER_SIGMA 1.5
#define COLORS_REPEAT_PROB 5.0

/* FUNCTIONS */

/*
 * bye - finish executing and show a message
 */
void bye(char *string)
{
	cout << string << endl;
	exit(1);
}

/*
* urnd - generate numbers with uniform random distribution
*  if flag=false, the interval is [a, b]
*  if flag=true, the interval is [a, b)
*/
float urnd(float a, float b, bool flag)
{
	return a + rand() * (b - a) / ((float)RAND_MAX + (flag ? 1.0 : 0.0));
}

/*
* grnd - generate numbers with gaussian random distribution
* (it uses Box-Muller algorithm)
*/
float grnd(float mu, float sigma)
{
	float z, u1, u2;

	/* u1 and u2 are given from an uniform distribution of (0, 1] */
	u1 = 1.0 - urnd(0, 1, true);
	u2 = 1.0 - urnd(0, 1, true);

	if (urnd(0, 1, 1) < 0.5) z = sqrt(-2.0 * log(u1)) * cos(2.0 * PI * u2);
	else z = sqrt(-2.0 * log(u1)) * sin(2.0 * PI * u2);
	return z * sigma + mu;
}

/*
 * main - Main program
 */
int main(int argc, char **argv)
{
	cout << "GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem." << endl;

	if (argc < 2 || argc == 3 || argc == 4 || argc == 5 || argc == 6) {
		cout << "Usage: genrandominst file [colors lb_cost ub_cost repeat qprob [prom sigma]] " << endl;
		cout << "It takes file.graph and generates file.cost and file.list." << endl;
		cout << "If the number of colors is not given, it uses parameters for a typical transport problem." << endl;
		cout << "Parameters:" << endl;
		cout << "  colors = number of colors" << endl;
		cout << "  lb_cost, ub_cost = bounds on the cost of each color (generated by a uniform distribution)" << endl;
		cout << "  repeat = prob. (0%-100%) for a color to be repeated" << endl;
		cout << "    (0% - all Gk different each other, 50% - colors/2 repeated once in average, 100% - G1 repeated \"colors\" times" << endl;
		cout << "  qprob = prob. (1%-100%) of including a color in L(v), for each v" << endl;
		cout << "    if qprob=0, lists L(v) are generated from Gk with param. prom and sigma:" << endl;
		cout << "  prom = average of the size of V(Gk) (vertices per color)" << endl;
		cout << "  sigma = standard dev. of the size of V(Gk)" << endl << endl;
		cout << "To generate an instance of the classic coloring problem use:" << endl;
		cout << "  genrandominst file colors 1 1 100 100" << endl;
		bye("Bye!");
	}

	char *filename = argv[1];
	bool transport = true;
	int colors;
	float lb_cost, ub_cost, repeat, qprob, prom, sigma;
	bool genGk = true;
	if (argc >= 7) {
		cout << "Using user-defined parameters" << endl;
		transport = false;
		colors = atoi(argv[2]);
		if (colors < 3 || colors > 50000) bye("Number of colors out range!");
		lb_cost = atof(argv[3]);
		ub_cost = atof(argv[4]);
		if (lb_cost < 1.0 || lb_cost > ub_cost || ub_cost > 1000.0) bye("Bounds should satisfy 1 <= lb_cost <= ub_cost <= 1000!");
		int repeat_int = atoi(argv[5]);
		if (repeat_int < 0 || repeat_int > 100) bye("repeat param. out of range!");
		repeat = (float)repeat_int;
		int qprob_int = atoi(argv[6]);
		if (qprob_int < 0 || qprob_int > 100) bye("qprob param. out of range!");
		qprob = (float)qprob_int;
		if (qprob_int > 0) genGk = false;
		else {
			if (argc < 9) bye("Average and sigma parameters must be given!");
			prom = atof(argv[7]);
			sigma = atof(argv[8]);
			if (prom < 3.0 || prom > 1000.0 || sigma < 0.0) bye("Average and/or sigma param. out of range!");
		}
	}
	else cout << "Using default parameters (for a typical transport instance)" << endl;

	/* open graph file */
	char filename_extension[210];
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".graph");
	FILE *stream = fopen(filename_extension, "rt");
	if (!stream) bye("Graph file cannot be opened");
	int vertices, edges;
	fscanf(stream, "%d:%d\n", &vertices, &edges);
	fclose(stream);

	/* do not accept graph of less than 4 vertices or stable sets */
	if (vertices < 4) bye("Number of vertices out range!");
	if (edges < 1 || edges > vertices*(vertices - 1) / 2) bye("Number of edges out of range!");
	/* the number of colors depends on the number of edges in a transport instance */
	if (transport) {
		colors = (int)((float)edges / EDGES_PER_COLOR);
		repeat = COLORS_REPEAT_PROB;
	}

	cout << "Statistics:" << endl;
	int clique_size = vertices * (vertices - 1) / 2;
	float density = 100.0 * (float)edges / (float)clique_size;
	cout << "  |V| = " << vertices << ", |E| = " << edges << " (density = " << density << "%), |C| = " << colors << "." << endl << endl;

	/* generate multiplicity of colors with "repeat" parameter:
	     repeated[k] = false   if k is not a repeated color
		 repeated[k] = true    if k is color q, where repeated[q] = false, repeated[q+1] = ... = repeated[k-1] = true
	   Extreme cases:
	     if repeat = 0% then repeated[k] = false for all k (all colors are different)
		 if repeat = 100% then repeated[0] = false, repeated[k] = true for all k >= 1 (classic coloring)
	   Variable numcolorsrep stores a histogram of repeated colors */
	srand(time(0));
	bool *repeated = new bool[colors];
	repeated[0] = false;
	int originals = 1;
	int q = 0;
	int numcolorsrep[4];
	numcolorsrep[0] = 1; numcolorsrep[1] = 0; numcolorsrep[2] = 0; numcolorsrep[3] = 0;
	for (int k = 1; k < colors; k++) {
		bool flag = repeat > urnd(0.0, 100.0, true) ? true : false;
		repeated[k] = flag;
		if (flag) {
			/* repeated color: update histogram accordingly */
			if (k - q < 4) {
				numcolorsrep[k - q - 1]--;
				numcolorsrep[k - q]++;
			}
		}
		else {
			/* original color */
			originals++;
			numcolorsrep[0]++;
			q = k;
		}
	}
	cout << "Repeat parameter = " << repeat << "%" << ", number of original colors = " << originals << "." << endl;
	cout << "Histogram:" << endl;
	cout << "  Non-repeated colors        (1 ocurrence)   = " << numcolorsrep[0] << endl;
	cout << "  Colors repeated once       (2 ocurrences)  = " << numcolorsrep[1] << endl;
	cout << "  Colors repeated twice      (3 ocurrences)  = " << numcolorsrep[2] << endl;
	cout << "  Colors repeated more times (4+ ocurrences) = " << numcolorsrep[3] << endl;
	if (originals != numcolorsrep[0] + numcolorsrep[1] + numcolorsrep[2] + numcolorsrep[3]) bye("Internal error (histogram)!");

	/* generate costs and write them to file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".cost");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("Cost file cannot be created");
	fprintf(stream, "%d\n", colors);
	int cost;
	for (int k = 0; k < colors; k++) {
		if (repeated[k] == false) { /* <-- k is a new color, recompute a cost */
			if (transport) {
				/* in half of the cases the cost is 480, in the rest it varies from 480 to 560 */
				cost = (int)urnd(400.0, 560.0, false);
				if (cost < 480) cost = 480;
			}
			else cost = (int)urnd(lb_cost, ub_cost, false);
		}
		fprintf(stream, "%d ", cost);
	}
	fprintf(stream, "\n");
	fclose(stream);

	/* generate vertices of graph Gk */
	if (transport) {
		prom = log((double)colors) / LOG_COLORS_PER_AVERAGE;
		sigma = prom / AVERAGES_PER_SIGMA;
	}
	if (genGk) cout << "Using size of V(Gk) with prom = " << prom << ", sigma = " << sigma << "." << endl;
	else cout << "Using q probability = " << qprob << "%." << endl;
	int *L_size = new int[vertices];
	int **L_set = new int*[vertices];
	for (int v = 0; v < vertices; v++) {
		L_size[v] = 0;
		L_set[v] = new int[colors];
	}
	for (int k = 0; k < colors; k++) {
		if (repeated[k] == false) { /* <-- k is a new color, recompute */
			float prob = qprob;
			if (genGk) {
				/* Using Gk generation. Note: average of |V(Gk)| can not be less than 3 */
				float C_size = grnd(prom, sigma);
				if (C_size < 3.0) C_size = 3.0;
				prob = 100.0 * C_size / (float)vertices;
				//cout << "  Trying |V(G" << k << ")| = " << C_size << "  (qprob = " << prob << "%)" << endl;
			}
			int count = 0;
			for (int v = 0; v < vertices; v++) {
				if (urnd(0.0, 100.0, false) <= prob) {
					L_set[v][L_size[v]] = k;
					L_size[v]++;
					count++;
				}
			}
			if (count == 0) {
				/* force an addition of at least 1 vertex to the color */
				int v = (int)urnd(0, vertices, true);
				L_set[v][L_size[v]] = k;
				L_size[v]++;
			}
		}
		else {
			/* copy G(k-1) to Gk (note that k-1 should be the last color added to L_set[v]) */
			for (int v = 0; v < vertices; v++) {
				if (L_size[v] > 0) {
					if (L_set[v][L_size[v] - 1] == k - 1) {
						L_set[v][L_size[v]] = k;
						L_size[v]++;
					}
				}
			}
		}
	}
	cout << endl;

	/* write them to list file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".list");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("List file cannot be created");
	fprintf(stream, "%d:%d\n", vertices, colors);
	for (int v = 0; v < vertices; v++) {
		int lv = L_size[v];
		fprintf(stream, "%d  ", lv);
		for (int s = 0; s < lv; s++) fprintf(stream, "%d ", L_set[v][s]);
		fprintf(stream, "\n");
	}
	fclose(stream);

	/* make some statistics and checks */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".graph");
	stream = fopen(filename_extension, "rt");
	if (!stream) bye("Graph file cannot be opened");
	fscanf(stream, "%d:%d\n", &vertices, &edges);
	bool **adjacency = new bool*[vertices];
	for (int u = 0; u < vertices; u++) {
		adjacency[u] = new bool[vertices];
		for (int v = 0; v < vertices; v++) adjacency[u][v] = false;
	}

	/* read edges, but only consider effective ones */
	int effective_edges = 0;
	for (int e = 0; e < edges; e++) {
		int u, v;
		fscanf(stream, "%d,%d\n", &u, &v);
		if (u < 0 || u >= v || v >= vertices) {
			cout << "Error reading edge " << e + 1 << "!" << endl;
			bye("Bye!");
		}
		else {
			/* do not consider those (u,v) such that L(u) cap L(v) = emptyset (only effective edges)*/
			bool intersection = false;
			for (int su = 0; su < L_size[u]; su++) {
				int k = L_set[u][su];
				for (int sv = 0; sv < L_size[v]; sv++) {
					if (L_set[v][sv] == k) {
						intersection = true;
						goto jump;
					}
				}
			}
			//cout << "Discarding (" << u << ", " << v << ") since they do not share colors in their lists" << endl;
		jump:;
			if (intersection) {
				adjacency[u][v] = true;
				adjacency[v][u] = true;
				effective_edges++;
			}
		}
	}
	fclose(stream);
	cout << "More stats:" << endl;
	density = 100.0 * (float)effective_edges / (float)clique_size;
	cout << "  Effective edges = " << effective_edges << " (density = " << density << "%)" << endl;

	/* we ask for memory and fill the distance matrix with 0 in the diagonal, 1 for neighbors and +inf for the remaining entries */
	int **dist = new int*[vertices];
	for (int u = 0; u < vertices; u++) {
		dist[u] = new int[vertices];
		for (int v = 0; v < vertices; v++) {
			int d = INFDIST;
			if (u == v)	d = 0;
			else { if (adjacency[u][v]) d = 1; }
			dist[u][v] = d;
		}
	}

	/* we use a simple implementation of Floyd algorithm (note: it is not the best way of knowing if G is connected!) */
	for (int v = 0; v < vertices; v++) {
		for (int u = 0; u < vertices; u++) {
			for (int w = 0; w < vertices; w++) {
				int sum = dist[u][v] + dist[v][w];
				if (sum < dist[u][w]) dist[u][w] = sum;
			}
		}
	}

	/* compute diameter */
	int diameter = 0;
	for (int u = 0; u < vertices - 1; u++) {
		for (int v = u + 1; v < vertices; v++) {
			int d = dist[u][v];
			if (d >= INFDIST) {
				cout << "Not connected: there is no path between " << u << " and " << v << "!" << endl;
				return false;
			}
			if (diameter < d) diameter = d;
		}
	}
	cout << "  Diameter of G = " << diameter << endl;

	/* free memory */
	for (int v = 0; v < vertices; v++) delete[] dist[v];
	delete[] dist;
	for (int v = 0; v < vertices; v++) delete[] adjacency[v];
	delete[] adjacency;
	for (int v = 0; v < vertices; v++) delete[] L_set[v];
	delete[] L_set;
	delete[] L_size;
	delete[] repeated;
	return 0;
}
