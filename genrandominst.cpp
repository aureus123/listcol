/*
 * GENRANDOMINST - Generate a random instance of Weighted List Coloring Problem from a graph
 * Made in 2018-2020 by Daniel Severin
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#include <iostream>

#ifdef VISUALC
#include <ctime>
#endif

using namespace std;

/* CONSTANTS */

#define PI 3.14159265358979323846
#define INFDIST 9999999

/* FUNCTIONS */

/*
 * bye - finish executing and show a message
 */
void bye(char *string)
{
	cout << string << endl;
	exit(-1);
}

/*
 * urnd - generate numbers with uniform random distribution in the interval is [a, b)
 */
float urnd(float a, float b)
{
	return a + rand() * (b - a) / ((float)RAND_MAX + 1.0);
}

/*
 * main - Main program
 */
int main(int argc, char **argv)
{
	cout << "GENRANDOMINST - Generate a random instance of Weighted List Coloring Problem." << endl;

	if (argc < 7) {
		cout << "Usage: genrandominst file dis_colors lb_cost ub_cost max_repeat qprob" << endl;
		cout << "It takes file.graph and generates file.cost and file.list." << endl;
		cout << "Warning: it also rewrites file.graph (removes useless edges)." << endl;
		cout << "Parameters:" << endl;
		cout << "  dis_colors = number of distinguishable colors (card. of K)" << endl;
		cout << "  lb_cost, ub_cost = bounds on the cost of each color (generated by a uniform distribution)" << endl;
		cout << "  max_repeat = max times the color is repeated (uniform distribution between 1 and max_repeat)" << endl;
		cout << "  qprob = prob. (1%-100%) of including a color (and its indistinguishables) in L(v), for each v" << endl;
		bye("Bye!");
	}

	char *filename = argv[1];
	int dis_colors = atoi(argv[2]);
	if (dis_colors < 3 || dis_colors > 10000) bye("Number of colors out range!");
	int lb_cost = atoi(argv[3]);
	int ub_cost = atoi(argv[4]);
	if (lb_cost < 1 || lb_cost > ub_cost || ub_cost > 1000) bye("Bounds should satisfy 1 <= lb_cost <= ub_cost <= 1000!");
	int max_repeat = atoi(argv[5]);
	if (max_repeat < 0 || max_repeat > 100) bye("max_repeat param. out of range!");
	int qprob = atoi(argv[6]);
	if (qprob < 1 || qprob > 100) bye("qprob param. out of range!");

	/* open graph file */
	char filename_extension[210];
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".graph");
	FILE *stream = fopen(filename_extension, "rt");
	if (!stream) bye("Graph file cannot be opened");
	int vertices, edges;
	fscanf(stream, "%d:%d\n", &vertices, &edges);
	fclose(stream);

	/* do not accept graph of less than 4 vertices or stable sets */
	if (vertices < 4) bye("Number of vertices out range!");
	if (edges < 1 || edges > vertices*(vertices - 1) / 2) bye("Number of edges out of range!");

	/* generate multiplicity of colors with "max_repeat" parameter:
	     repeated[c] = false   if c is not a repeated color
		 repeated[c] = true    if c is color q, where repeated[q] = false, repeated[q+1] = ... = repeated[c-1] = true
	   Extreme case:
	     if max_repeat = 1 then repeated[k] = false for all k (all colors are different) */
	srand(time(0));
	int colors = 0;
	bool *repeated = new bool[dis_colors*max_repeat];
	for (int k = 0; k < dis_colors; k++) {
		repeated[colors++] = false;
		int multiplicity = (int)urnd(0.0, (float)max_repeat);
		for (int m = 0; m < multiplicity; m++) repeated[colors++] = true;
	}

	/* show some stats */
	cout << "Statistics:" << endl;
	int clique_size = vertices * (vertices - 1) / 2;
	float density = 100.0 * (float)edges / (float)clique_size;
	cout << "  |V| = " << vertices << ", |E| = " << edges << " (density = " << density << "%)" << endl;
	cout << "  |K| = " << dis_colors << ", |C| = " << colors << endl;
	cout << "  max_repeat = " << max_repeat << ", q prob. = " << qprob << "%" << endl;
	cout << "  costs: LB = " << lb_cost << ", UB = " << ub_cost << endl;

	/* generate costs and write them to file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".cost");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("Cost file cannot be created");
	fprintf(stream, "%d\n", colors);
	int cost;
	for (int k = 0; k < colors; k++) {
		if (repeated[k] == false) /* <-- k is a new color, recompute a cost */
			cost = (int)urnd((float)lb_cost, (float)(ub_cost+1));
		fprintf(stream, "%d ", cost);
	}
	fprintf(stream, "\n");
	fclose(stream);

	/* generate vertices of graph Gk */
	int *L_size = new int[vertices];
	int **L_set = new int*[vertices];
	for (int v = 0; v < vertices; v++) {
		L_size[v] = 0;
		L_set[v] = new int[colors];
	}
	for (int k = 0; k < colors; k++) {
		if (repeated[k] == false) { /* <-- k is a new color, recompute */
			int count = 0;
			for (int v = 0; v < vertices; v++) {
				if (urnd(0.0, 100.0) <= (float)qprob) {
					L_set[v][L_size[v]] = k;
					L_size[v]++;
					count++;
				}
			}
			if (count == 0) {
				/* force an addition of at least 1 vertex to the color */
				int v = (int)urnd(0.0, (float)vertices);
				L_set[v][L_size[v]] = k;
				L_size[v]++;
			}
		}
		else {
			/* copy G(k-1) to Gk (note that k-1 should be the last color added to L_set[v]) */
			for (int v = 0; v < vertices; v++) {
				if (L_size[v] > 0) {
					if (L_set[v][L_size[v] - 1] == k - 1) {
						L_set[v][L_size[v]] = k;
						L_size[v]++;
					}
				}
			}
		}
	}

	/* write them to list file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".list");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("List file cannot be created");
	fprintf(stream, "%d:%d\n", vertices, colors);
	for (int v = 0; v < vertices; v++) {
		int lv = L_size[v];
		fprintf(stream, "%d  ", lv);
		for (int s = 0; s < lv; s++) fprintf(stream, "%d ", L_set[v][s]);
		fprintf(stream, "\n");
	}
	fclose(stream);

	/* idea of the following code: read the graph and remove useless edges */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".graph");
	stream = fopen(filename_extension, "rt");
	if (!stream) bye("Graph file cannot be opened");
	fscanf(stream, "%d:%d\n", &vertices, &edges);
	bool **adjacency = new bool*[vertices];
	for (int u = 0; u < vertices; u++) {
		adjacency[u] = new bool[vertices];
		for (int v = 0; v < vertices; v++) adjacency[u][v] = false;
	}

	/* read edges, but only consider effective ones */
	int effective_edges = 0;
	for (int e = 0; e < edges; e++) {
		int u, v;
		fscanf(stream, "%d,%d\n", &u, &v);
		if (u < 0 || u >= v || v >= vertices) {
			cout << "Error reading edge " << e + 1 << "!" << endl;
			bye("Bye!");
		}
		else {
			/* do not consider those (u,v) such that L(u) cap L(v) = emptyset */
			bool intersection = false;
			for (int su = 0; su < L_size[u]; su++) {
				int k = L_set[u][su];
				for (int sv = 0; sv < L_size[v]; sv++) {
					if (L_set[v][sv] == k) {
						intersection = true;
						goto jump;
					}
				}
			}
		jump:;
			if (intersection) {
				adjacency[u][v] = true;
				adjacency[v][u] = true;
				effective_edges++;
			}
		}
	}
	fclose(stream);

	if (effective_edges == 0) { bye("Error! No edges left (try with another graph) :("); }

	/* now write to the graph */
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("Graph file cannot be re-written");
	fprintf(stream, "%d:%d\n", vertices, effective_edges);
	for (int u = 0; u < vertices - 1; u++) {
		for (int v = u + 1; v < vertices; v++) {
			if (adjacency[u][v]) fprintf(stream, "%d,%d\n", u, v);
		}
	}
	fclose(stream);

	cout << "Final graph:" << endl;
	density = 100.0 * (float)effective_edges / (float)clique_size;
	cout << "  Effective edges = " << effective_edges << " (density = " << density << "%)" << endl;

	/* we ask for memory and fill the distance matrix with 0 in the diagonal, 1 for neighbors and +inf for the remaining entries */
	int **dist = new int*[vertices];
	for (int u = 0; u < vertices; u++) {
		dist[u] = new int[vertices];
		for (int v = 0; v < vertices; v++) {
			int d = INFDIST;
			if (u == v)	d = 0;
			else { if (adjacency[u][v]) d = 1; }
			dist[u][v] = d;
		}
	}

	/* we use a simple implementation of Floyd algorithm (note: it is not the best way of knowing if G is connected!) */
	for (int v = 0; v < vertices; v++) {
		for (int u = 0; u < vertices; u++) {
			for (int w = 0; w < vertices; w++) {
				int sum = dist[u][v] + dist[v][w];
				if (sum < dist[u][w]) dist[u][w] = sum;
			}
		}
	}

	/* compute diameter */
	int diameter = 0;
	for (int u = 0; u < vertices - 1; u++) {
		for (int v = u + 1; v < vertices; v++) {
			int d = dist[u][v];
			if (d >= INFDIST) {
				cout << "Not connected: there is no path between " << u << " and " << v << "!" << endl;
				goto jump2;
			}
			if (diameter < d) diameter = d;
		}
	}
	cout << "  Diameter of G = " << diameter << endl;

jump2:;
	/* free memory */
	for (int v = 0; v < vertices; v++) delete[] dist[v];
	delete[] dist;
	for (int v = 0; v < vertices; v++) delete[] adjacency[v];
	delete[] adjacency;
	for (int v = 0; v < vertices; v++) delete[] L_set[v];
	delete[] L_set;
	delete[] L_size;
	delete[] repeated;
	return 0;
}
