/*
 * GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem from a graph
 * Made in 2018 by Daniel Severin and Mauro Lucci
 *
 */

#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <iostream>
#include <cstring>

using namespace std;

/* CONSTANTS */

#define PI 3.14159265358979323846
#define EDGES_PER_COLOR 3.14
#define LOG_COLORS_PER_AVERAGE 0.785
#define AVERAGES_PER_SIGMA 1.5

/* FUNCTIONS */

/*
 * bye - finish executing and show a message
 */
void bye(char *string)
{
	cout << string << endl;
	exit(1);
}

/*
* urnd - generate numbers with uniform random distribution
*  if flag=false, the interval is [a, b]
*  if flag=true, the interval is [a, b)
*/
float urnd(float a, float b, bool flag)
{
    if (!flag)
        return a + rand() * (b - a) / (float) RAND_MAX;
	else
        return a + (rand() % RAND_MAX) * (b - a) / (float) RAND_MAX;
}

/*
* grnd - generate numbers with gaussian random distribution
* (it uses Box-Muller algorithm)
*/
float grnd(float mu, float sigma)
{
	float z, u1, u2;

	/* u1 and u2 are given from an uniform distribution of (0, 1] */
	u1 = 1.0 - urnd(0, 1, true);
	u2 = 1.0 - urnd(0, 1, true);

	if (urnd(0, 1, 1) < 0.5) z = sqrt(-2.0 * log(u1)) * cos(2.0 * PI * u2);
	else z = sqrt(-2.0 * log(u1)) * sin(2.0 * PI * u2);
	return z * sigma + mu;
}

/*
 * main - Main program
 */
int main(int argc, char **argv)
{
	cout << "GENRANDOMINST - Generate a random instance of Minimum Cost List Coloring Problem." << endl;

	if (argc < 2 || argc == 3 || argc == 4 || argc == 5 || argc == 6) {
		cout << "Usage: genrandominst file [colors lb_cost ub_cost prom sigma] " << endl;
		cout << "It takes file.graph and generates file.cost and file.list." << endl;
		cout << "If the number of colors is not given, it uses parameters for a typical transport problem." << endl;
		cout << "Parameters:" << endl;
		cout << "  colors = number of colors" << endl;
		cout << "  lb_cost, ub_cost = bounds on the cost of each color (generated by a uniform distribution)" << endl;
		cout << "  prom = average of the size of V(Gk) (vertices per color)" << endl;
		cout << "  sigma = standard dev. of the size of V(Gk)" << endl;
		bye("Bye!");
	}

	char *filename = argv[1];
	bool transport = true;
	int colors;
	float lb_cost, ub_cost, prom, sigma;
	if (argc >= 7) {
		cout << "Using user-defined parameters" << endl;
		colors = atoi(argv[2]);
		if (colors < 3 || colors > 50000) bye("Number of colors out range!");
		lb_cost = atof(argv[3]);
		ub_cost = atof(argv[4]);
		if (lb_cost < 1.0 || lb_cost > ub_cost || ub_cost > 1000.0) bye("Bounds should satisfy 1 <= lb_cost <= ub_cost <= 1000!");
		prom = atof(argv[5]);
		sigma = atof(argv[6]);
		if (prom < 3.0 || prom > 1000.0 || sigma < 0.0) bye("Average and/or sigma out of range!");
		transport = false;
	}
	else cout << "Using default parameters (for a typical transport instance)" << endl;

	/* open graph file */
	char filename_extension[210];
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".graph");
	FILE *stream = fopen(filename_extension, "rt");
	if (!stream) bye("Graph file cannot be opened");
	int vertices, edges;
	fscanf(stream, "%d:%d\n", &vertices, &edges);

	/* do not accept graph of less than 4 vertices or stable sets */
	if (vertices < 4) bye("Number of vertices out range!");
	if (edges < 1 || edges > vertices*(vertices - 1) / 2) bye("Number of edges out of range!");

	/* ask for memory */
	//int *degrees = new int[vertices];
	//int **adjacency = new int*[vertices];
	//for (int u = 0; u < vertices; u++) {
	//	degrees[u] = 0;
	//	adjacency[u] = new int[vertices];
	//	for (int v = 0; v < vertices; v++) adjacency[u][v] = 0;
	//}
	//int *edge_u = new int[edges];
	//int *edge_v = new int[edges];

	/* read edges */
	//for (int e = 0; e < edges; e++) {
	//	int u, v;
	//	fscanf(stream, "%d,%d\n", &u, &v);
	//	if (u < 0 || u >= v || v >= vertices) {
	//		cout << "Error reading edge " << e + 1 << "!" << endl;
	//		bye("Bye!");
	//	}
	//	if (adjacency[u][v] != 0) {
	//		cout << "A repeated edge was found: (" << u << ", " << v << ")" << endl;
	//		bye("Bye!");
	//	}
	//	else {
	//		degrees[u]++;
	//		degrees[v]++;
	//		edge_u[e] = u;
	//		edge_v[e] = v;
	//		adjacency[u][v] = e + 1;
	//		adjacency[v][u] = e + 1;
	//	}
	//}
	fclose(stream);

	/* the number of colors depends on the number of edges in a transport instance */
	if (transport) colors = (int)((float)edges / EDGES_PER_COLOR);

	cout << "Statistics:" << endl;
	int clique_size = vertices * (vertices - 1) / 2;
	float density = 100.0 * (float)edges / (float)clique_size;
	cout << "  |V| = " << vertices << ", |E| = " << edges << " (density = " << density << "%), |C| = " << colors << "." << endl;

	/* generate costs and write them to file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".cost");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("Cost file cannot be created");
	fprintf(stream, "%d\n", colors);
	for (int k = 0; k < colors; k++) {
		int cost;
		if (transport) {
			/* in half of the cases the cost is 480, in the rest it varies from 480 to 560 */
			cost = (int)urnd(400.0, 560.0, false);
			if (cost < 480) cost = 480;
		}
		else cost = (int)urnd(lb_cost, ub_cost, false);
		fprintf(stream, "%d ", cost);
	}
	fprintf(stream, "\n");
	fclose(stream);

	/* generate vertices of graph Gk */
	if (transport) {
		prom = log((double)colors) / LOG_COLORS_PER_AVERAGE;
		sigma = prom / AVERAGES_PER_SIGMA;
	}
	cout << "Using size of V(Gk) with prom = " << prom << ", sigma = " << sigma << "." << endl;
	int *L_size = new int[vertices];
	int **L_set = new int*[vertices];
	for (int v = 0; v < vertices; v++) {
		L_size[v] = 0;
		L_set[v] = new int[colors];
	}
	for (int k = 0; k < colors; k++) {
		/* note: average of |V(Gk)| can not be less than 3 */
		float C_size = grnd(prom, sigma);
		if (C_size < 3.0) C_size = 3.0;
		float prob = C_size / (float)vertices;
		int count = 0;
		for (int v = 0; v < vertices; v++) {
			if (urnd(0, 1, false) <= prob) {
				L_set[v][L_size[v]] = k;
				L_size[v]++;
				count++;
			}
		}
		if (count == 0) {
			/* force an addition of at least 1 vertex to the color */
			int v = (int)urnd(0, vertices, true);
			L_set[v][L_size[v]] = k;
			L_size[v]++;
		}
	}

	/* write them to list file */
	strncpy(filename_extension, filename, 200);
	strcat(filename_extension, ".list");
	stream = fopen(filename_extension, "wt");
	if (!stream) bye("List file cannot be created");
	fprintf(stream, "%d:%d\n", vertices, colors);
	for (int v = 0; v < vertices; v++) {
		int lv = L_size[v];
		fprintf(stream, "%d  ", lv);
		for (int s = 0; s < lv; s++) fprintf(stream, "%d ", L_set[v][s]);
		fprintf(stream, "\n");
	}
	fclose(stream);

	/* free memory */
	for (int v = 0; v < vertices; v++) delete[] L_set[v];
	delete[] L_set;
	delete[] L_size;
	//delete[] edge_v;
	//delete[] edge_u;
	//for (int v = 0; v < vertices; v++) delete[] adjacency[v];
	//delete[] adjacency;
	//delete[] degrees;
	return 0;
}
